package arrays;

import java.util.Arrays;

public class Day3 {
	/**
	 * 1>print the next permutsion
	 * 
	 * brute force find all the permutaions and search for the given next
	 * permutation n! for claculating al Time =O(n!
	 * 
	 */

	public void nextPermutation(int[] nums) {
		// get the number arr[i+1]>arr[i]
		int i = nums.length - 2;
		while (i >= 0 && nums[i + 1] <= nums[i]) {
			i--;
		}

		// swap with the next highest number
		if (i >= 0) {
			int j = nums.length - 1;
			while (nums[j] <= nums[i]) {
				j--;
			}
			sawp(nums, i, j);
		}
		// reverse the subarray i+1
		reverse(nums, i + 1);

	}

	private void reverse(int[] nums, int i) {
		int j = nums.length - 1;
		while (i <= j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
			i++;
			j--;
		}

	}

	private void sawp(int[] nums, int i, int j) {
		int temp = nums[i];
		nums[i] = nums[j];
		nums[j] = temp;

	}

	/**
	 * Q>2 . count the inversions
	 * 
	 * 
	 */
	static long inversionCount(long arr[], int  N) {
		return inversionCount_hepler(arr,0,N);
	}

	private static long inversionCount_hepler(long[] arr, int low, int high ) {
			// its is merge sort problem
		// total inversions =left+right+merge
		long ans=0;
		while(low<high) {
			int mid=(low+high)/2;
			//left 
			ans+=inversionCount_hepler(arr, low,mid);
			//right
			ans+=inversionCount_hepler(arr, mid+1,high);
			
			//merge 
			
			ans+=mergeAndCount(arr,low,mid,high);
			
		}
		
		
		return ans;
	}

	private static long mergeAndCount(long[] arr, int low, int mid, int high) {
			//left subarray
		long[] left=Arrays.copyOf(arr, mid);
		//right subarry
		long[] rigth=Arrays.copyOf(arr, mid+1,);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
